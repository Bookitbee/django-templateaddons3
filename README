#####################
Django-TemplateAddOns
#####################

************
Introduction
************

Django-TemplateAddOns is a set of tools for use with Django's templates:
* template tags;
* context processors;
* utilities for template tag development.

************
Installation
************

Requirements
============

This application requires:

* Django. The application targets the most recent release of branch 1.x.

Please install and configure these applications *before* this one.

Get the code
============

The code is published under the BSD license. See LICENSE for details.

The project page is http://bitbucket.org/benoitbryon/django-templateaddons/.

Copy the templateaddons folder somewhere in your PYTHON_PATH. It may be in your
project's directory.

Update settings
===============

* add 'templateaddons' to your INSTALLED_APPS

**********************
Template tag libraries
**********************

This application provides several template tags packaged into libraries.

Assign
======

The "assign" template tag library provides 1 template tag:

* assign: captures the output of template code and saves it in a context
  variable

assign
------

The {% assign %} template tag is useful when you want to capture some template
code output and use the result later.

It captures whatever is between the {% assign %} and {% endassign %} pair.

It takes two optional input parameters:

* name. A string. The context variable name where to store the result. Defaults 
  to "assign".
* silent. A boolean. Whether to only capture the output or both capture and 
  display it. Defaults to False.

The following template code::

  {% load assign %}
  {% assign name="sample_code" %}1234{% endassign %}
  5678
  {{ sample_code }}

... gives the following output::

  
  
  5678
  1234

Note: the {% assign %} template tag allows you to override the value of an 
existing context variable, so choose the "name" parameter with care.

The default value for the "name" parameter is "assign". This means that we
could have written the previous example as below::

  {% load assign %}
  {% assign %}1234{% endassign %}
  5678
  {{ assign }}

You can set the "silent" parameter to False if you want to capture and display
the output at the same time. The following template code::

  {% load assign %}
  {% assign name="sample_code" silent=0 %}1234{% endassign %}
  5678
  {{ sample_code }}

... gives the following output::

  
  1234
  5678
  1234

Counter
=======

The "counter" template tag library provides 2 template tags:

* counter: increments a counter on each call

counter
-------

The {% counter %} template tag is useful when you want to use a custom counter.
It can be used outside a specific loop, or used over multiple loops...

The {% counter %} template tag accepts several optional parameters:

* name. A string. It identifies the counter. Default value is 'default'.
* start. An integer. The value of the counter at the very first call. Default
  value is 0.
* step. An integer. The increment or decrement amount. Default value is 1.
* ascending. A boolean. Whether the counter is incremented (True) or 
  decremented (False). Default value is True.
* silent. Whether to render (False) or not (True) the current counter value.
  Default value is False.
* assign. A string. If not empty, the current value of the counter is assigned
  to the context variable with the corresponding name. Default value is "" (do
  not assign).

Notice that the start, ascending and step values are only parsed on counter
initialization.

The list of available counters is stored in the context, under the variable 
name settings.TEMPLATEADDONS_COUNTERS_VARIABLE, which is 
"_templateaddons_counters" by default.

Heading
=======

The "heading" template tag library provides 1 template tag:

* headingcontext: helps you manage heading levels in HTML code

headingcontext
--------------

With cascading templates, includes and bases, some parts of template code
could be reused in different heading contexts.

As an example, consider the following "home page" code in home.html::

  <h1>My beautiful website</h1>
  <h2>News</h2>
  <p>... links to news ...</p>

And consider the following "news page" code in news.html

  <h1>News</h1>
  <p>... links to news ...</p>

You cannot reuse (include) news.html code into home.html, because the heading
level does not match.

The "headingcontext" template tag allows you to solve this problem.
Here is modified home.html::

  {% load heading %}
  <h1>My beautiful website</h1>
  {% headingcontext %}
  {% include "news.html" %}
  {% endheadingcontext %}

Ok. Now, what if the news.html code was using h5 in place of h1 like that::

  <h5>News</h5>
  <p>... links to news ...</p>

You can use the additional "source_level" parameter in home.html::

  {% load heading %}
  <h1>My beautiful website</h1>
  {% headingcontext source_level=5 %}
  {% include "news.html" %}
  {% endheadingcontext %}

This causes all heading of level 5 and greater in news.html to be relative
to the current heading level (2).

You can use nested {% headingcontext %}{% endheadingcontext %} calls. As an
example, news.html could be::

  <h5>News</h5>
  <p>... links to news ...</p>
  {% load heading %}
  {% headingcontext source_level=3 target_level=6 %}
  {% include "another_template_fragment_which_contains_some_h3.html" %}
  {% endheadingcontext %}

Notice the use of the additional "target_level" parameter, which forces 
ouput levels to start at 6.

You can read the provided test cases to observe what does this template tag at
tests.HeadingContextTemplateTagTestCase.

******************
Context processors
******************

Documentation needed.

***************
Developer tools
***************

Documentation needed.
